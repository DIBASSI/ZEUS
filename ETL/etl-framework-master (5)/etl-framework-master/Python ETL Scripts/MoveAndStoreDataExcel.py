##Author: Reece Colbus##Contact: rcolbus@mac.com as of 2Oct18##Date Created: 07Oct18##Description: Processes an human generated Excel file ##Modification log:##20190220: Script generalized. - Bob Wakefield## 1. Verify file exists## 2. Load  Excel file - data on DATASET tab##    Create ProcessTimeStamp##    Create | delimitedfile with downloadTimeStamp prefix## 3. Delete  Excel file## 4. Update SQL Server database## 5. Create zip file for txt date## 6. Delete txt fileimport osimport sysimport datetimeimport pandas as pdimport pyodbc as dbimport zipfile as zf#Constants used to process data files#Exsiting paths are examples only!kFileXLSX = 'C:/FileDepot/../In/data.xlsx'#Full path of Excel file in public facing folderfileTimeStampedTXT = ''kIAEFDestination = 'C:/InterfaceAndExtractFiles/../In/' #path to processing IN folderkArchiveDestination = 'C:/InterfaceAndExtractFiles/../Archive/' #path to archive folderprint("Starting: Processing data")# Check if required file existsif not os.path.isfile(kFileXLSX):    sys.exit("ERROR: Unable to find file {}".format(kFileXLSX))# Read excel data into pandas and write | delimited txt filetry:    print("Reading Excel file: {}".format(kFileXLSX))    df = pd.read_excel(kFileXLSX, sheet_name="DATASET")    # set timestamp for file processing    print("Setting process timestamp")    processTimeStamp = datetime.datetime.today().strftime('%Y%m%d')    # Create txt filename wih timestamp    fileTimeStampedTXT = kIAEFDestination + processTimeStamp + "_data.txt"    print("Writing txt file to: {}".format(fileTimeStampedTXT))    df.to_csv(fileTimeStampedTXT, sep="|", index=False)except:    sys.exit("ERROR: Unable to read  Excel file and create txt file: {}".format(kFileXLSX))# delete xlsx filetry:    print("Deleting  xlsx file: {}".format(kFileXLSX))    if os.path.isfile(kFileXLSX):        os.remove(kFileXLSX)except:    sys.exit("ERROR: Unable to delete file: {}".format(kFileXLSX))# bulk load txt file to SQL Servertry:    print("Connecting to SQL Server database")    connection_string = 'DSN=ETL;'    conn = db.connect(connection_string)    print("Preparing database for update")    csr = conn.cursor()    csr.execute("DELETE FROM [stage table] WHERE Processed = 1")    print("Preparing bulk insert update")    sql = "BULK INSERT [stage table view] FROM '" + fileTimeStampedTXT + "' WITH (FIELDTERMINATOR = '|', ROWTERMINATOR = '0x0a', FIRSTROW = 2)"    print("Update database with {} file data.".format(fileTimeStampedTXT))    csr.execute(sql)    conn.commit()    csr.close()    conn.close()except db.OperationalError as err:    print('Error: ', err.value)    sys.exit("ERROR: Unable to update SQL Server stage table.")# zip txt file to archivetry:    zipFile = kArchiveDestination + processTimeStamp + "__data.zip"    print("Creating zip file for txt file archive")    archive = zf.ZipFile(zipFile, "w")    archive.write(fileTimeStampedTXT, os.path.basename(fileTimeStampedTXT))    archive.closeexcept:    sys.exit("ERROR: unable to create zip file for file: {}".format(fileTimeStampedTXT))# delete txt filetry:    print("Deleting  txt file: {}".format(fileTimeStampedTXT))    if os.path.isfile(fileTimeStampedTXT):        os.remove(fileTimeStampedTXT)except:    sys.exit("ERROR: Unable to delete file: {}".format(fileTimeStampedTXT))# Script Completeprint("Complete: Processing Data")